import express from 'express';
import { AuthenticatedRequest } from '../middleware/auth.middleware';
import {
  getTeams,
  getTeamById,
  createTeam,
  updateTeam,
  deleteTeam,
  assignAssistantToTeam,
  removeAssistantFromTeam,
  getAssistantsByTeam,
} from '../services/team.service';
import { Team } from '../models/Team';
import { generateTeamAvatarVariations } from '../services/dalle.service';
import { downloadAndCompressImage } from '../services/file-downloader.service';
import { getWorkspaceService } from '../services/unified-workspace.service';

const router = express.Router();

// AI-Powered Team Creation Wizard
// POST /api/teams/create-with-wizard
router.post('/create-with-wizard', async (req: AuthenticatedRequest, res) => {
  try {
    const { teamName, teamPurpose, selectedAvatarIndex } = req.body;
    const companyId = req.user!.companyId.toString();

    // Validate input
    if (!teamName || !teamPurpose) {
      return res.status(400).send({
        message: 'teamName and teamPurpose are required',
      });
    }

    // Step 1: Generate 3 avatar variations using DALL-E
    console.log(
      `Generating avatars for team "${teamName}" (company: ${companyId})`,
    );
    const avatarResults = await generateTeamAvatarVariations(
      {
        teamName,
        teamPurpose,
        companyId,
      },
      3,
    );

    // Filter successful generations
    const successfulAvatars = avatarResults.filter((r) => r.imageUrl);

    if (successfulAvatars.length === 0) {
      return res.status(500).send({
        message:
          'Failed to generate any avatars. Please check your OpenAI API key configuration.',
      });
    }

    // Step 2: Download and store avatar images in workspace
    const workspace = getWorkspaceService();
    const storedAvatars = [];

    for (const avatar of successfulAvatars) {
      try {
        // Download and compress image from DALL-E URL
        const imageBuffer = await downloadAndCompressImage(
          avatar.imageUrl,
          512,
          85,
        );

        // Generate workspace path
        const timestamp = new Date().getTime();
        const path = `/company/${companyId}/team-avatars/temp/${teamName}-${timestamp}-style${avatar.styleIndex}.jpg`;

        // Store in workspace
        await workspace.set(path, imageBuffer, {
          contentType: 'image/jpeg',
          generatedBy: 'dall-e-3',
          prompt: avatar.revisedPrompt || 'Generated by DALL-E 3',
          teamName,
          teamPurpose,
          styleIndex: avatar.styleIndex,
          companyId,
          createdAt: new Date(),
          ttl: 1800, // 30 minutes TTL for temp storage
        });

        storedAvatars.push({
          styleIndex: avatar.styleIndex,
          path,
          revisedPrompt: avatar.revisedPrompt,
        });

        console.log(
          `Stored avatar ${avatar.styleIndex + 1}/${successfulAvatars.length} at ${path}`,
        );
      } catch (error) {
        console.error(
          `Failed to download/store avatar ${avatar.styleIndex}:`,
          error,
        );
      }
    }

    if (storedAvatars.length === 0) {
      return res.status(500).send({
        message: 'Failed to store generated avatars. Please try again.',
      });
    }

    // Step 3: If selectedAvatarIndex is provided, create the team
    if (
      selectedAvatarIndex !== undefined &&
      selectedAvatarIndex !== null &&
      selectedAvatarIndex >= 0
    ) {
      const selectedAvatar = storedAvatars.find(
        (a) => a.styleIndex === selectedAvatarIndex,
      );

      if (!selectedAvatar) {
        return res.status(400).send({
          message: `Selected avatar index ${selectedAvatarIndex} not found in generated avatars`,
        });
      }

      // Move selected avatar to permanent storage
      const imageBuffer = await workspace.get(selectedAvatar.path);
      const permanentPath = `/company/${companyId}/team-avatars/${teamName}-${new Date().getTime()}.jpg`;

      await workspace.set(permanentPath, imageBuffer, {
        contentType: 'image/jpeg',
        generatedBy: 'dall-e-3',
        prompt: selectedAvatar.revisedPrompt,
        teamName,
        teamPurpose,
        styleIndex: selectedAvatar.styleIndex,
        companyId,
        createdAt: new Date(),
        // No TTL = permanent storage
      });

      // Create the team with workspace avatar
      const teamData: any = {
        name: teamName,
        description: teamPurpose,
        icon: permanentPath, // Workspace path
        iconType: 'workspace' as const,
        companyId: req.user?.companyId,
      };

      const team = await createTeam(teamData);

      // Send response immediately
      res.status(201).send({
        team,
        selectedAvatar: {
          path: permanentPath,
          styleIndex: selectedAvatar.styleIndex,
        },
      });

      // Clean up temp avatars asynchronously (non-blocking)
      Promise.all(
        storedAvatars.map((avatar) => workspace.delete(avatar.path)),
      ).catch((err) => console.error('Failed to cleanup temp avatars:', err));

      return;
    }

    // Step 4: Return generated avatars for user selection
    res.status(200).send({
      message: 'Avatars generated successfully',
      avatars: storedAvatars.map((a) => ({
        styleIndex: a.styleIndex,
        path: a.path,
        // Use the public workspace endpoint (no auth required) for team avatars
        downloadUrl: `/workspace/get?path=${encodeURIComponent(a.path)}`,
      })),
      teamName,
      teamPurpose,
    });
  } catch (error: any) {
    console.error('Error in team creation wizard:', error);

    // Check for OpenAI API key error
    if (error.message?.includes('OpenAI API key')) {
      return res.status(400).send({
        message: error.message,
        fallback:
          'You can still create a team manually with an emoji or Lucide icon.',
      });
    }

    res.status(500).send({
      message: 'Error in team creation wizard',
      error: error.message,
    });
  }
});

// Get all teams for a company
router.get('/', async (req: AuthenticatedRequest, res) => {
  try {
    const teams = await getTeams(req.user!.companyId.toString());
    res.send(teams);
  } catch (error) {
    console.error('Error retrieving teams:', error);
    res.status(500).send({ message: 'Error retrieving teams' });
  }
});

// Get team by ID
router.get('/:id', async (req: AuthenticatedRequest, res) => {
  try {
    const team = await getTeamById(req.params.id);
    if (!team) {
      return res.status(404).send({ message: 'Team not found' });
    }

    // Check if the team belongs to the user's company or if the user is an Admin
    if (
      req.user?.role !== 'Admin' &&
      team.companyId.toString() !== req.user?.companyId.toString()
    ) {
      return res.status(403).send({ message: 'Access denied' });
    }

    res.send(team);
  } catch (error) {
    console.error('Error retrieving team:', error);
    res.status(500).send({ message: 'Error retrieving team' });
  }
});

// Create a new team
router.post('/', async (req: AuthenticatedRequest, res) => {
  try {
    const teamData = {
      ...req.body,
      companyId: req.user?.companyId,
    };

    const team = await createTeam(teamData);
    res.status(201).send(team);
  } catch (error) {
    console.error('Error creating team:', error);
    res.status(500).send({ message: 'Error creating team' });
  }
});

// Update a team
router.put('/:id', async (req: AuthenticatedRequest, res) => {
  try {
    const { id } = req.params;
    const teamData = req.body;

    // Ensure the team belongs to the user's company
    const team = await getTeamById(id);
    if (!team) {
      return res.status(404).send({ message: 'Team not found' });
    }

    if (
      req.user?.role !== 'Admin' &&
      team.companyId.toString() !== req.user?.companyId.toString()
    ) {
      return res.status(403).send({ message: 'Access denied' });
    }

    const updatedTeam = await updateTeam(id, teamData);
    res.send(updatedTeam);
  } catch (error) {
    console.error('Error updating team:', error);
    res.status(500).send({ message: 'Error updating team' });
  }
});

// Delete a team
router.delete('/:id', async (req: AuthenticatedRequest, res) => {
  try {
    const { id } = req.params;

    // Ensure the team belongs to the user's company
    const team = await getTeamById(id);
    if (!team) {
      return res.status(404).send({ message: 'Team not found' });
    }

    if (
      req.user?.role !== 'Admin' &&
      team.companyId.toString() !== req.user?.companyId.toString()
    ) {
      return res.status(403).send({ message: 'Access denied' });
    }

    await deleteTeam(id);
    res.send({ message: 'Team deleted successfully' });
  } catch (error) {
    console.error('Error deleting team:', error);
    res.status(500).send({ message: 'Error deleting team' });
  }
});

// Get assistants by team
router.get('/:id/assistants', async (req: AuthenticatedRequest, res) => {
  try {
    const { id } = req.params;

    // Ensure the team belongs to the user's company
    const team = await getTeamById(id);
    if (!team) {
      return res.status(404).send({ message: 'Team not found' });
    }

    if (
      req.user?.role !== 'Admin' &&
      team.companyId.toString() !== req.user?.companyId.toString()
    ) {
      return res.status(403).send({ message: 'Access denied' });
    }

    const assistants = await getAssistantsByTeam(id);
    res.send(assistants);
  } catch (error) {
    console.error('Error retrieving assistants by team:', error);
    res.status(500).send({ message: 'Error retrieving assistants by team' });
  }
});

// Assign assistant to team
router.post(
  '/:teamId/assistants/:assistantId',
  async (req: AuthenticatedRequest, res) => {
    try {
      const { teamId, assistantId } = req.params;

      // Ensure the team belongs to the user's company
      const team = await getTeamById(teamId);
      if (!team) {
        return res.status(404).send({ message: 'Team not found' });
      }

      if (
        req.user?.role !== 'Admin' &&
        team.companyId.toString() !== req.user?.companyId.toString()
      ) {
        return res.status(403).send({ message: 'Access denied' });
      }

      await assignAssistantToTeam(assistantId, teamId);
      res.send({ message: 'Assistant assigned to team successfully' });
    } catch (error) {
      console.error('Error assigning assistant to team:', error);
      res.status(500).send({ message: 'Error assigning assistant to team' });
    }
  },
);

// Remove assistant from team
router.delete(
  '/:teamId/assistants/:assistantId',
  async (req: AuthenticatedRequest, res) => {
    try {
      const { teamId, assistantId } = req.params;

      // Ensure the team belongs to the user's company
      const team = await getTeamById(teamId);
      if (!team) {
        return res.status(404).send({ message: 'Team not found' });
      }

      if (
        req.user?.role !== 'Admin' &&
        team.companyId.toString() !== req.user?.companyId.toString()
      ) {
        return res.status(403).send({ message: 'Access denied' });
      }

      await removeAssistantFromTeam(assistantId, teamId);
      res.send({ message: 'Assistant removed from team successfully' });
    } catch (error) {
      console.error('Error removing assistant from team:', error);
      res.status(500).send({ message: 'Error removing assistant from team' });
    }
  },
);

export { router as teamRouter };
